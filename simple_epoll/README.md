# EPOLL

epoll 是Linux I/O 多路复用接口 select/poll 的改进，epoll也是实现I/O多路复用的一种方法。



## 触发方式

epoll的工作模式有水平触发（level trigger，LT，默认工作模式）与边缘触发（edge trigger，ET）两种。
使用脉冲信号来解释LT和ET可能更加贴切。
Level是指信号只需要处于水平，就一直会触发；
而Edge则是指信号为上升沿或者下降沿时触发。

### 水平触发(level-triggered)

如果文件描述符已经就绪可以非阻塞的执行IO操作了，此时会触发通知。
允许在任意时刻重复检测IO的状态。

select、poll就属于水平触发。

支持阻塞和非阻塞的IO操作。

### 边缘触发(edge-triggered)

如果文件描述符自上次状态改变后有新的IO活动到来，此时会触发通知。

在收到一个IO事件通知后要尽可能多的执行IO操作，因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述符。

信号驱动式IO就属于边缘触发

仅支持非阻塞的IO操作。

### 水平触发和边缘触发模式区别

1. 读缓冲区刚开始是空的
2. 读缓冲区写入2KB数据
3. 水平触发和边缘触发模式此时都会发出可读信号
4. 收到信号通知后，读取了1kb的数据，读缓冲区还剩余1KB数据
5. 水平触发会再次进行通知，而边缘触发不会再进行通知
所以，边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN为止，EGAIN说明缓冲区已经空了，因为这一点，边缘触发需要设置文件句柄为非阻塞

在读的场景下，水平触发可以一次性不读完，有剩余未读的数据，水平触发会再次进行通知，而边缘触发不会再进行通知。

```c++
ret = read(fd, buf, sizeof(buf));
```

边缘触发需要一次性的把缓冲区的数据读完为止，也就是一直读，直到读到EGAIN为止，EGAIN说明缓冲区已经空了。

```c++
while(true) {
    ret = read(fd, buf, sizeof(buf);
    if (ret == EAGAIN) break;
}
```

通俗来讲就是：

* 水平触发：你能读多少就读多少，反正只要有数据可读我就会通知你的。
* 边缘触发：你必须读完我让你读的所有数据，否则你再也没东西读了。

## 参考文档

* [IO模型-水平触发与边缘触发](https://hyiki.github.io/reference/2020/03/31/LT-ET.html)
* [epoll:水平触发与边缘触发](https://www.jianshu.com/p/7eaa0224d797)
